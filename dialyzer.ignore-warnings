:0: Unknown function 'Elixir.Aewallet.KeyPair':compress/1
:0: Unknown function 'Elixir.Aewallet.KeyPair':derive/2
:0: Unknown function 'Elixir.Aewallet.KeyPair':generate_master_key/1
:0: Unknown function 'Elixir.Aewallet.KeyPair':generate_pub_key/1
:0: Unknown function 'Elixir.Aewallet.Signing':sign/2
:0: Unknown function 'Elixir.Aewallet.Signing':verify/3
:0: Unknown function 'Elixir.Aewallet.Wallet':create_wallet/2
:0: Unknown function 'Elixir.Aewallet.Wallet':get_private_key/3
:0: Unknown function 'Elixir.Aewallet.Wallet':get_public_key/3
:0: Unknown function 'Elixir.Aewallet.Wallet':get_seed/2
:0: Unknown function 'Elixir.ExJsonSchema.Schema':resolve/1
:0: Unknown function 'Elixir.ExJsonSchema.Validator':validate/2
:0: Unknown function 'Elixir.ExRLP':decode/1
:0: Unknown function 'Elixir.ExRLP':encode/1
:0: Unknown function 'Elixir.MerklePatriciaTree.DB.ExternalDB':init/1
:0: Unknown function 'Elixir.MerklePatriciaTree.Proof':construct_proof/1
:0: Unknown function 'Elixir.MerklePatriciaTree.Proof':verify_proof/4
:0: Unknown function 'Elixir.MerklePatriciaTree.Trie':delete/2
:0: Unknown function 'Elixir.MerklePatriciaTree.Trie':get/2
:0: Unknown function 'Elixir.MerklePatriciaTree.Trie':new/1
:0: Unknown function 'Elixir.MerklePatriciaTree.Trie':new/2
:0: Unknown function 'Elixir.MerklePatriciaTree.Trie':update/3
:0: Unknown function 'Elixir.MerklePatriciaTree.Trie.Inspector':all_keys/1
:0: Unknown function 'Elixir.Msgpax':'pack!'/1
:0: Unknown function 'Elixir.Msgpax':'pack!'/2
:0: Unknown function 'Elixir.Msgpax':unpack/1
:0: Unknown function 'Elixir.Serialization':rlp_encode/2
:0: Unknown function base58:base58_to_binary/1
:0: Unknown function base58:binary_to_base58/1
:0: Unknown function enacl:generichash/2
:0: Unknown function sha3:hash/2
:0: Unknown type 'Elixir.MerklePatriciaTree.Trie':key/0
:0: Unknown type 'Elixir.MerklePatriciaTree.Trie':t/0
:0: Unknown type 'Elixir.MerklePatriciaTree.Trie':value/0
Function put/3 has no local return
Function update/3 has no local return
Function process_chainstate/5 has no local return
The created fun has no local return
Function deduct_fee/5 has no local return
Function check_peer/2 has no local return
Function standard_deduct_fee/4 has no local return
Function get_info/1 has no local return
Function get_block/1 has no local return
Function get_raw_blocks/1 has no local return
Function get_pool_txs/1 has no local return
Function send_block/2 has no local return
Function send_tx/2 has no local return
Function spend/4 has no local return
Function spend/7 has no local return
Function get_peers/1 has no local return
Function get_and_add_peers/1 has no local return
Function get_account_balance/1 has no local return
Function get_account_txs/1 has no local return
Function get/1 has no local return
Function get/2 has no local return
Function handle_info/2 has no local return
Function trim_peers/1 will never be called
Function 'should_a_peer_be_added?'/1 will never be called
Function broadcast_new_block_added_to_chain_and_new_mined_tx/1 has no local return
Function block_by_hash/2 has no local return

Overloaded contract for 'Elixir.Aecore.Naming.NameUtil':validate_label_length/1 has overlapping domains; such contracts are currently unsupported and are simply ignored
Overloaded contract for 'Elixir.Aecore.Wallet.Worker':has_wallet/2 has overlapping domains; such contracts are currently unsupported and are simply ignored
Overloaded contract for 'Elixir.Aeutil.PatriciaMerkleTree':new/1 has overlapping domains; such contracts are currently unsupported and are simply ignored

The call maps:put(#{#<116>(8, 1, 'integer', ['unsigned', 'big']), #<114>(8, 1, 'integer', ['unsigned', 'big']), #<97>(8, 1, 'integer', ['unsigned', 'big']), #<110>(8, 1, 'integer', ['unsigned', 'big']), #<115>(8, 1, 'integer', ['unsigned', 'big']), #<97>(8, 1, 'integer', ['unsigned', 'big']), #<99>(8, 1, 'integer', ['unsigned', 'big']), #<116>(8, 1, 'integer', ['unsigned', 'big']), #<105>(8, 1, 'integer', ['unsigned', 'big']), #<111>(8, 1, 'integer', ['unsigned', 'big']), #<110>(8, 1, 'integer', ['unsigned', 'big']), #<115>(8, 1, 'integer', ['unsigned', 'big'])}#,Vserialized_txs@1::[any()],Vserialized_header@1::binary()) will never return since it differs in the 3rd argument from the success typing arguments: (any(),any(),map())

#### Wrong spec type in the function called Exexec.send
The call 'Elixir.Exexec':send(Vospid@1::non_neg_integer(),'eof') breaks the contract (pid() | os_pid(),binary()) -> 'ok'

#### We will fix this after chainstate becomes a PMT!!!  
The call 'Elixir.Aeutil.Serialization':remove_struct(Vchain_states@1::{'error',_} | {'ok',map()}) breaks the contract ([any()]) -> [any()]
    ; (map()) -> map() in the 1st argument

#### Outdated code!!! Have to be fixed!!! In apps/aehttpserver/lib/aehttpserver/web/controllers/block_controller
The pattern {'error', 'block_not_found'} can never match the type {'error',binary()}
The pattern {'error', 'invalid_hash'} can never match the type {'error',binary()}

#### Outdated code!!! Have to be fixed!!! In apps/aehttpserver/lib/aehttpserver/web/controllers/tx_controller.ex:23
The call 'Elixir.Aeutil.Serialization':serialize_txs_info_to_json(Vuser_txs@1::[any(),...]) will never return since the success typing is ([atom() | #{'block_hash':=binary(), 'block_height':=_, 'fee':=non_neg_integer(), 'nonce':=integer(), 'payload':=map(), 'senders':=binary() | [any()], 'signatures':=_, 'type':='Elixir.Aecore.Account.Tx.CoinbaseTx' | 'Elixir.Aecore.Account.Tx.SpendTx' | 'Elixir.Aecore.Naming.Tx.NameClaimTx' | 'Elixir.Aecore.Naming.Tx.NamePreClaimTx' | 'Elixir.Aecore.Naming.Tx.NameRevokeTx' | 'Elixir.Aecore.Naming.Tx.NameTransferTx' | 'Elixir.Aecore.Naming.Tx.NameUpdateTx' | 'Elixir.Aecore.Oracle.Tx.OracleExtendTx' | 'Elixir.Aecore.Oracle.Tx.OracleQueryTx' | 'Elixir.Aecore.Oracle.Tx.OracleRegistrationTx' | 'Elixir.Aecore.Oracle.Tx.OracleResponseTx', _=>_}]) -> [any()] and the contract is ([raw_data()]) -> [map()]
#### Outdated code!!! Have to be fixed!!! In apps/aehttpserver/lib/aehttpserver/web/controllers/tx_controller.ex:31
The call 'Elixir.Aeutil.Serialization':serialize_txs_info_to_json(Vuser_txs@1::[any(),...]) will never return since the success typing is ([atom() | #{'block_hash':=binary(), 'block_height':=_, 'fee':=non_neg_integer(), 'nonce':=integer(), 'payload':=map(), 'senders':=binary() | [any()], 'signatures':=_, 'type':='Elixir.Aecore.Account.Tx.SpendTx' | 'Elixir.Aecore.Naming.Tx.NameClaimTx' | 'Elixir.Aecore.Naming.Tx.NamePreClaimTx' | 'Elixir.Aecore.Naming.Tx.NameRevokeTx' | 'Elixir.Aecore.Naming.Tx.NameTransferTx' | 'Elixir.Aecore.Naming.Tx.NameUpdateTx' | 'Elixir.Aecore.Oracle.Tx.OracleExtendTx' | 'Elixir.Aecore.Oracle.Tx.OracleQueryTx' | 'Elixir.Aecore.Oracle.Tx.OracleRegistrationTx' | 'Elixir.Aecore.Oracle.Tx.OracleResponseTx', _=>_}]) -> [any()] and the contract is ([raw_data()]) -> [map()]

Guard test '/='(Verror@1::'nil','nil') can never succeed

The call 'Elixir.Aehttpserver.Web.Notify':broadcast_new_transaction_in_the_pool(Vtx@1::#{'__struct__':='Elixir.Aecore.Tx.SignedTx', 'data':=#{'__struct__':='Elixir.Aecore.Tx.DataTx', 'fee':=non_neg_integer(), 'nonce':=non_neg_integer(), 'payload':=#{'__struct__':='Elixir.Aecore.Account.Tx.SpendTx' | 'Elixir.Aecore.Naming.Tx.NameClaimTx' | 'Elixir.Aecore.Naming.Tx.NamePreClaimTx' | 'Elixir.Aecore.Naming.Tx.NameRevokeTx' | 'Elixir.Aecore.Naming.Tx.NameTransferTx' | 'Elixir.Aecore.Naming.Tx.NameUpdateTx' | 'Elixir.Aecore.Oracle.Tx.OracleExtendTx' | 'Elixir.Aecore.Oracle.Tx.OracleQueryTx' | 'Elixir.Aecore.Oracle.Tx.OracleRegistrationTx' | 'Elixir.Aecore.Oracle.Tx.OracleResponseTx', 'amount'=>non_neg_integer(), 'client_ttl'=>non_neg_integer(), 'commitment'=>binary(), 'expire_by'=>non_neg_integer(), 'hash'=>binary(), 'name'=>binary(), 'name_salt'=>binary(), 'oracle_address'=>binary(), 'payload'=>binary(), 'pointers'=>binary(), 'query_data'=>_, 'query_fee'=>non_neg_integer(), 'query_format'=>map(), 'query_id'=>binary(), 'query_ttl'=>#{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'receiver'=>binary(), 'response'=>map(), 'response_format'=>map(), 'response_ttl'=>#{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'target'=>binary(), 'ttl'=>non_neg_integer() | #{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'version'=>non_neg_integer()}, 'senders':=[binary()], 'type':='Elixir.Aecore.Account.Tx.SpendTx' | 'Elixir.Aecore.Naming.Tx.NameClaimTx' | 'Elixir.Aecore.Naming.Tx.NamePreClaimTx' | 'Elixir.Aecore.Naming.Tx.NameRevokeTx' | 'Elixir.Aecore.Naming.Tx.NameTransferTx' | 'Elixir.Aecore.Naming.Tx.NameUpdateTx' | 'Elixir.Aecore.Oracle.Tx.OracleExtendTx' | 'Elixir.Aecore.Oracle.Tx.OracleQueryTx' | 'Elixir.Aecore.Oracle.Tx.OracleRegistrationTx' | 'Elixir.Aecore.Oracle.Tx.OracleResponseTx'}, 'signatures':=[binary()]}) will never return since it differs in the 1st argument from the success typing arguments: (#{'__struct__':='Elixir.Aecore.Tx.SignedTx', 'data':=#{'__struct__':='Elixir.Aecore.Tx.DataTx', 'fee':=atom() | binary() | [any()] | map(), 'nonce':=atom() | binary() | [any()] | map(), 'payload':=atom() | binary() | [any()] | map(), 'senders':=[any()], 'type':=atom() | binary() | [any()] | map(), _=>_}, 'signatures':=[any()], _=>_})
The pattern #{'txs':=_@2} can never match the type {'error',atom() | binary()} | {'ok',#{'__struct__':='Elixir.Aecore.Chain.Block', 'header':=#{'__struct__':='Elixir.Aecore.Chain.Header', 'height':=non_neg_integer(), 'miner':=binary(), 'nonce':=non_neg_integer(), 'pow_evidence':=_, 'prev_hash':=binary(), 'root_hash':=binary(), 'target':=non_neg_integer(), 'time':=non_neg_integer(), 'txs_hash':=binary(), 'version':=non_neg_integer()}, 'txs':=[#{'__struct__':='Elixir.Aecore.Tx.SignedTx', 'data':=#{'__struct__':='Elixir.Aecore.Tx.DataTx', 'fee':=non_neg_integer(), 'nonce':=non_neg_integer(), 'payload':=#{'__struct__':='Elixir.Aecore.Account.Tx.SpendTx' | 'Elixir.Aecore.Naming.Tx.NameClaimTx' | 'Elixir.Aecore.Naming.Tx.NamePreClaimTx' | 'Elixir.Aecore.Naming.Tx.NameRevokeTx' | 'Elixir.Aecore.Naming.Tx.NameTransferTx' | 'Elixir.Aecore.Naming.Tx.NameUpdateTx' | 'Elixir.Aecore.Oracle.Tx.OracleExtendTx' | 'Elixir.Aecore.Oracle.Tx.OracleQueryTx' | 'Elixir.Aecore.Oracle.Tx.OracleRegistrationTx' | 'Elixir.Aecore.Oracle.Tx.OracleResponseTx', 'amount'=>non_neg_integer(), 'client_ttl'=>non_neg_integer(), 'commitment'=>binary(), 'expire_by'=>non_neg_integer(), 'hash'=>binary(), 'name'=>binary(), 'name_salt'=>binary(), 'oracle_address'=>binary(), 'payload'=>binary(), 'pointers'=>binary(), 'query_data'=>_, 'query_fee'=>non_neg_integer(), 'query_format'=>map(), 'query_id'=>binary(), 'query_ttl'=>#{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'receiver'=>binary(), 'response'=>map(), 'response_format'=>map(), 'response_ttl'=>#{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'target'=>binary(), 'ttl'=>non_neg_integer() | #{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'version'=>non_neg_integer()}, 'senders':=[binary()], 'type':='Elixir.Aecore.Account.Tx.SpendTx' | 'Elixir.Aecore.Naming.Tx.NameClaimTx' | 'Elixir.Aecore.Naming.Tx.NamePreClaimTx' | 'Elixir.Aecore.Naming.Tx.NameRevokeTx' | 'Elixir.Aecore.Naming.Tx.NameTransferTx' | 'Elixir.Aecore.Naming.Tx.NameUpdateTx' | 'Elixir.Aecore.Oracle.Tx.OracleExtendTx' | 'Elixir.Aecore.Oracle.Tx.OracleQueryTx' | 'Elixir.Aecore.Oracle.Tx.OracleRegistrationTx' | 'Elixir.Aecore.Oracle.Tx.OracleResponseTx'}, 'signatures':=[binary()]}]}}
The call 'Elixir.Aeutil.Serialization':block(Vblock@1::any(),'serialize') will never return since it differs in the 2nd argument from the success typing arguments: (map(),'deserialize')
The call 'Elixir.Aeutil.Serialization':block(Vblock@1::atom() | #{'txs':=_, _=>_},'serialize') will never return since it differs in the 2nd argument from the success typing arguments: (map(),'deserialize')
The call 'Elixir.Aeutil.Serialization':block(Vblock@1::#{'__struct__':='Elixir.Aecore.Chain.Block', 'header':=#{'__struct__':='Elixir.Aecore.Chain.Header', 'height':=non_neg_integer(), 'miner':=binary(), 'nonce':=non_neg_integer(), 'pow_evidence':=_, 'prev_hash':=binary(), 'root_hash':=binary(), 'target':=non_neg_integer(), 'time':=non_neg_integer(), 'txs_hash':=binary(), 'version':=non_neg_integer()}, 'txs':=[#{'__struct__':='Elixir.Aecore.Tx.SignedTx', 'data':=#{'__struct__':='Elixir.Aecore.Tx.DataTx', 'fee':=non_neg_integer(), 'nonce':=non_neg_integer(), 'payload':=#{'__struct__':='Elixir.Aecore.Account.Tx.SpendTx' | 'Elixir.Aecore.Naming.Tx.NameClaimTx' | 'Elixir.Aecore.Naming.Tx.NamePreClaimTx' | 'Elixir.Aecore.Naming.Tx.NameRevokeTx' | 'Elixir.Aecore.Naming.Tx.NameTransferTx' | 'Elixir.Aecore.Naming.Tx.NameUpdateTx' | 'Elixir.Aecore.Oracle.Tx.OracleExtendTx' | 'Elixir.Aecore.Oracle.Tx.OracleQueryTx' | 'Elixir.Aecore.Oracle.Tx.OracleRegistrationTx' | 'Elixir.Aecore.Oracle.Tx.OracleResponseTx', 'amount'=>non_neg_integer(), 'client_ttl'=>non_neg_integer(), 'commitment'=>binary(), 'expire_by'=>non_neg_integer(), 'hash'=>binary(), 'name'=>binary(), 'name_salt'=>binary(), 'oracle_address'=>binary(), 'payload'=>binary(), 'pointers'=>binary(), 'query_data'=>_, 'query_fee'=>non_neg_integer(), 'query_format'=>map(), 'query_id'=>binary(), 'query_ttl'=>#{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'receiver'=>binary(), 'response'=>map(), 'response_format'=>map(), 'response_ttl'=>#{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'target'=>binary(), 'ttl'=>non_neg_integer() | #{'ttl':=non_neg_integer(), 'type':='absolute' | 'relative'}, 'version'=>non_neg_integer()}, 'senders':=[binary()], 'type':='Elixir.Aecore.Account.Tx.SpendTx' | 'Elixir.Aecore.Naming.Tx.NameClaimTx' | 'Elixir.Aecore.Naming.Tx.NamePreClaimTx' | 'Elixir.Aecore.Naming.Tx.NameRevokeTx' | 'Elixir.Aecore.Naming.Tx.NameTransferTx' | 'Elixir.Aecore.Naming.Tx.NameUpdateTx' | 'Elixir.Aecore.Oracle.Tx.OracleExtendTx' | 'Elixir.Aecore.Oracle.Tx.OracleQueryTx' | 'Elixir.Aecore.Oracle.Tx.OracleRegistrationTx' | 'Elixir.Aecore.Oracle.Tx.OracleResponseTx'}, 'signatures':=[binary()]}]},'serialize') will never return since it differs in the 2nd argument from the success typing arguments: (map(),'deserialize')
The call 'Elixir.Aeutil.Serialization':block(Vblock@1::atom() | #{'header':=_, _=>_},'serialize') will never return since it differs in the 2nd argument from the success typing arguments: (map(),'deserialize')
The call 'Elixir.Aeutil.Serialization':block(Vblock@1::any(),'serialize') will never return since it differs in the 2nd argument from the success typing arguments: (map(),'deserialize')
